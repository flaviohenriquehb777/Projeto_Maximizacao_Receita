#!/usr/bin/env python3
"""
Script para reescrever o hist√≥rico Git de forma realista e profissional.
Distribui commits entre janeiro-junho 2022 com mensagens contextualizadas para ML/Data Science.
"""

import os
import subprocess
import sys
from datetime import datetime, timedelta
import random

def run_command(cmd, check=True):
    """Executa comando shell e retorna resultado."""
    print(f"Executando: {cmd}")
    result = subprocess.run(cmd, shell=True, capture_output=True, text=True)
    if check and result.returncode != 0:
        print(f"Erro ao executar: {cmd}")
        print(f"Stderr: {result.stderr}")
        sys.exit(1)
    return result

def generate_dates(start_date, end_date, num_commits):
    """Gera datas distribu√≠das de forma realista no per√≠odo."""
    dates = []
    total_days = (end_date - start_date).days
    
    # Distribuir commits de forma mais realista (mais no in√≠cio e meio do projeto)
    for i in range(num_commits):
        # Usar distribui√ß√£o beta para simular desenvolvimento real
        # Mais commits no in√≠cio e meio, menos no final
        beta_sample = random.betavariate(2, 3)  # Concentra no in√≠cio/meio
        day_offset = int(beta_sample * total_days)
        
        # Adicionar alguma aleatoriedade para evitar padr√µes √≥bvios
        day_offset += random.randint(-2, 2)
        day_offset = max(0, min(day_offset, total_days))
        
        commit_date = start_date + timedelta(days=day_offset)
        
        # Hor√°rios de trabalho realistas (9h-18h, com alguns extras)
        if random.random() < 0.8:  # 80% durante hor√°rio comercial
            hour = random.randint(9, 18)
        else:  # 20% fora do hor√°rio (dedica√ß√£o extra)
            hour = random.choice([8, 19, 20, 21])
        
        minute = random.randint(0, 59)
        commit_date = commit_date.replace(hour=hour, minute=minute)
        dates.append(commit_date)
    
    # Ordenar datas cronologicamente
    dates.sort()
    return dates

def get_ml_commit_messages():
    """Retorna mensagens de commit contextualizadas para projeto ML/Data Science."""
    return [
        # In√≠cio do projeto - Setup e estrutura
        "feat: inicializar projeto de maximiza√ß√£o de receita",
        "setup: configurar estrutura inicial do projeto",
        "feat: adicionar carregamento e inspe√ß√£o inicial dos dados",
        "docs: adicionar documenta√ß√£o inicial do projeto",
        "setup: configurar ambiente Python e depend√™ncias",
        
        # An√°lise explorat√≥ria
        "feat: implementar an√°lise explorat√≥ria de dados (EDA)",
        "feat: adicionar visualiza√ß√µes para entender distribui√ß√£o de pre√ßos",
        "feat: analisar correla√ß√£o entre pre√ßo, desconto e quantidade",
        "feat: identificar outliers nos dados de vendas",
        "feat: criar gr√°ficos de dispers√£o pre√ßo vs quantidade",
        "feat: implementar estat√≠sticas descritivas dos dados",
        
        # Pr√©-processamento
        "feat: implementar pr√©-processamento de dados",
        "feat: adicionar tratamento de valores ausentes",
        "feat: implementar normaliza√ß√£o com MinMaxScaler",
        "feat: adicionar RobustScaler para tratamento de outliers",
        "feat: criar pipeline de pr√©-processamento",
        "refactor: otimizar pipeline de transforma√ß√£o de dados",
        
        # Modelagem
        "feat: implementar modelo de regress√£o linear",
        "feat: adicionar divis√£o treino/teste dos dados",
        "feat: implementar valida√ß√£o cruzada do modelo",
        "feat: adicionar m√©tricas de avalia√ß√£o (RMSE, R¬≤)",
        "feat: implementar curva de aprendizado",
        "perf: otimizar hiperpar√¢metros do modelo",
        
        # Otimiza√ß√£o de receita
        "feat: implementar algoritmo de otimiza√ß√£o de receita",
        "feat: adicionar busca por pre√ßo e desconto ideais",
        "feat: implementar fun√ß√£o objetivo para maximiza√ß√£o",
        "feat: adicionar valida√ß√£o dos resultados de otimiza√ß√£o",
        "feat: criar cen√°rios de otimiza√ß√£o de receita",
        
        # Visualiza√ß√µes e resultados
        "feat: adicionar visualiza√ß√µes dos resultados",
        "feat: criar gr√°ficos de performance do modelo",
        "feat: implementar dashboard de m√©tricas",
        "feat: adicionar visualiza√ß√£o da curva de aprendizado",
        "feat: criar gr√°ficos de otimiza√ß√£o de receita",
        
        # Melhorias e refinamentos
        "refactor: reorganizar c√≥digo em m√≥dulos",
        "perf: otimizar performance do algoritmo de otimiza√ß√£o",
        "feat: adicionar logging detalhado",
        "test: implementar testes unit√°rios",
        "feat: adicionar valida√ß√£o de entrada de dados",
        "refactor: melhorar legibilidade do c√≥digo",
        
        # Documenta√ß√£o e finaliza√ß√£o
        "docs: atualizar documenta√ß√£o com resultados",
        "docs: adicionar exemplos de uso",
        "feat: criar relat√≥rio final de resultados",
        "docs: documentar metodologia utilizada",
        "feat: adicionar exporta√ß√£o de resultados",
        "docs: finalizar documenta√ß√£o do projeto",
        
        # Commits t√©cnicos diversos
        "fix: corrigir bug na normaliza√ß√£o de dados",
        "fix: resolver problema de divis√£o por zero",
        "style: aplicar formata√ß√£o PEP8",
        "refactor: extrair fun√ß√µes auxiliares",
        "perf: melhorar efici√™ncia do algoritmo",
        "feat: adicionar tratamento de exce√ß√µes",
        "fix: corrigir c√°lculo de m√©tricas",
        "feat: implementar cache para otimiza√ß√£o",
        "refactor: simplificar l√≥gica de valida√ß√£o",
        "feat: adicionar configura√ß√µes flex√≠veis",
        
        # Commits de integra√ß√£o e deploy
        "ci: configurar pipeline de CI/CD",
        "feat: adicionar scripts de automa√ß√£o",
        "ci: implementar testes automatizados",
        "deploy: preparar para entrega ao time",
        "docs: criar guia de deployment",
        "feat: adicionar monitoramento de performance",
        "ci: configurar valida√ß√£o autom√°tica",
        "deploy: finalizar prepara√ß√£o para produ√ß√£o"
    ]

def main():
    print("üöÄ Iniciando reescrita do hist√≥rico Git...")
    
    # Configura√ß√µes do projeto
    start_date = datetime(2022, 1, 15)  # Janeiro 2022
    end_date = datetime(2022, 6, 30)    # Junho 2022
    
    # Solicitar n√∫mero de commits
    try:
        num_commits = int(input("Quantos commits deseja gerar? (recomendado: 150-200): "))
    except (ValueError, EOFError):
        num_commits = 180  # Valor padr√£o profissional
    
    print(f"Gerando {num_commits} commits entre {start_date.strftime('%d/%m/%Y')} e {end_date.strftime('%d/%m/%Y')}")
    
    # Gerar datas e mensagens
    dates = generate_dates(start_date, end_date, num_commits)
    messages = get_ml_commit_messages()
    
    # Garantir que temos mensagens suficientes
    while len(messages) < num_commits:
        messages.extend(messages[:num_commits - len(messages)])
    
    # Embaralhar mensagens para distribui√ß√£o natural
    random.shuffle(messages)
    messages = messages[:num_commits]
    
    # Verificar se estamos na branch main
    result = run_command("git branch --show-current")
    current_branch = result.stdout.strip()
    if current_branch != "main":
        print(f"Mudando da branch '{current_branch}' para 'main'")
        run_command("git checkout main")
    
    # Criar nova branch √≥rf√£ para reescrita
    print("Criando nova branch √≥rf√£ para reescrita...")
    run_command("git checkout --orphan temp-rewrite")
    
    # Adicionar todos os arquivos no primeiro commit
    print("Adicionando todos os arquivos...")
    run_command("git add .")
    
    # Criar commits com datas e mensagens distribu√≠das
    print(f"Criando {num_commits} commits...")
    for i, (date, message) in enumerate(zip(dates, messages)):
        # Formato de data para Git
        date_str = date.strftime("%Y-%m-%d %H:%M:%S")
        
        # Configurar data do commit
        env = os.environ.copy()
        env["GIT_AUTHOR_DATE"] = date_str
        env["GIT_COMMITTER_DATE"] = date_str
        
        # Fazer pequenas modifica√ß√µes para cada commit (exceto o primeiro)
        if i > 0:
            # Criar ou modificar README para simular desenvolvimento
            readme_file = "README.md"
            if os.path.exists(readme_file):
                with open(readme_file, "a", encoding="utf-8") as f:
                    f.write(f"\n<!-- Progress: {i+1}/{num_commits} - {date_str} -->")
                run_command(f"git add {readme_file}")
        
        # Criar commit com data espec√≠fica
        cmd = f'git commit -m "{message}"'
        result = subprocess.run(cmd, shell=True, env=env, capture_output=True, text=True)
        
        if result.returncode != 0:
            print(f"Erro no commit {i+1}: {result.stderr}")
            continue
            
        if (i + 1) % 20 == 0:
            print(f"Progresso: {i+1}/{num_commits} commits criados")
    
    # Substituir a branch main
    print("Substituindo branch main...")
    run_command("git checkout main")
    run_command("git reset --hard temp-rewrite")
    run_command("git branch -D temp-rewrite")
    
    # Limpar coment√°rios tempor√°rios do README
    readme_file = "README.md"
    if os.path.exists(readme_file):
        with open(readme_file, "r", encoding="utf-8") as f:
            content = f.read()
        
        # Remover coment√°rios de progresso
        lines = content.split('\n')
        clean_lines = [line for line in lines if not line.strip().startswith('<!-- Progress:')]
        
        with open(readme_file, "w", encoding="utf-8") as f:
            f.write('\n'.join(clean_lines))
        
        run_command("git add README.md")
        run_command('git commit -m "chore: limpar coment√°rios tempor√°rios"')
    
    print("‚úÖ Reescrita do hist√≥rico conclu√≠da!")
    print(f"‚úÖ {num_commits} commits criados entre {start_date.strftime('%d/%m/%Y')} e {end_date.strftime('%d/%m/%Y')}")
    print("‚úÖ Todos os arquivos do projeto foram preservados")
    
    # Verificar resultado
    result = run_command("git rev-list --count HEAD")
    final_count = int(result.stdout.strip())
    print(f"‚úÖ Total de commits no reposit√≥rio: {final_count}")
    
    print("\nüîç Pr√≥ximos passos:")
    print("1. Verificar o resultado com: git log --oneline -10")
    print("2. Fazer push com: git push --force-with-lease origin main")

if __name__ == "__main__":
    main()